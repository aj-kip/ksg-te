/****************************************************************************

    File: TextRenderer.cpp
    Author: Andrew Janke
    License: GPLv3

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

*****************************************************************************/

#include "TextRenderer.hpp"
#include "TextRendererTests.hpp"
#include "TextGrid.hpp"

#include <cassert>

namespace {

class TextGridWriter final : public GridWriter {
public:
    TextGridWriter(): write_position(0, 0), parent_grid(nullptr) {}
    void write(ColorPair, Cursor, const std::u32string &) override;
    void write(ColorPair, Cursor, UChar) override;
    int width() const override;
    int height() const override;

    Cursor write_position;
    TextGrid * parent_grid;
private:
    void verify_parent_present(const char * funcname) const;
};

/** Assumption, string is written entirely on one line.
 *  @param grid_pos
 *  @param text_pos
 */
void record_cursor_mappings
    (TextLineGridDoubleMap *, Cursor grid_pos, Cursor text_pos, const std::u32string &);

void record_cursor_mappings
    (TextLineGridDoubleMap *, Cursor grid_pos, Cursor text_pos);

} // end of <anonymous> namespace

/* static */ const sf::Color TextRenderer::default_keyword_fore_c = sf::Color(200, 200, 0);
/* static */ const sf::Color TextRenderer::default_keyword_back_c;
/* static */ const sf::Color TextRenderer::default_fore_c = sf::Color::White;
/* static */ const sf::Color TextRenderer::default_back_c = sf::Color(12, 12, 12);
/* static */ const sf::Color TextRenderer::default_select_fore_c;
/* static */ const sf::Color TextRenderer::default_select_back_c;

GridWriter::~GridWriter() {}

Cursor GridWriter::next_cursor(Cursor cur) const {
    verify_cursor_validity("HighlighterPriv::GridWriter::next_cursor", cur);
    ++cur.column;
    if (cur.column == width()) {
        ++cur.line;
        cur.column = 0;
    }
    return cur;
}

Cursor GridWriter::end_cursor() const
    { return Cursor(height(), 0); }

/* protected */ void GridWriter::verify_cursor_validity
    (const char * funcname, Cursor cur) const
{
    if (cur.column < width() && cur.line < height() &&
        cur.column >= 0 && cur.line >= 0)
    {
        return;
    }
    throw std::out_of_range(std::string(funcname) +
                            ": invalid cursor falls outside of grid.");
}

ColorPair TextRenderer::HighlightInfo::pair_for_word
    (const std::u32string & word) const
{
    if (keywords.find(word) == keywords.end()) {
        return ColorPair(default_fore, default_back);
    } else {
        return ColorPair(keyword_fore, default_back);
    }
}

TextRenderer::TextRenderer():
    m_cursor_maps(nullptr)
{}

void TextRenderer::setup_defaults() {
    m_info.default_back = default_back_c;
    m_info.default_fore = default_fore_c;
    m_info.keyword_fore = default_keyword_fore_c;
    m_info.select_back  = default_select_back_c;
    m_info.select_fore  = default_select_fore_c;
}

void TextRenderer::render_lines_to
    (TextGrid * text_grid, Cursor starting_point, const TextLines & tlines)
{
    render_lines_to(text_grid, starting_point, tlines, UserTextSelection());
}

void TextRenderer::render_lines_to
    (TextGrid * text_grid, Cursor starting_point, const TextLines & tlines,
     const UserTextSelection & selection)
{
    TextGridWriter writer;
    writer.parent_grid    = text_grid;
    writer.write_position = starting_point;
    render_lines_to(writer, starting_point, tlines, selection);
}

/* private */ void TextRenderer::render_lines_to
    (GridWriter & writer, Cursor textlines_cursor, const TextLines & tlines,
     const UserTextSelection & selection)
{
    const auto height_c = writer.height();
#   if 0
    m_target_writer  = &writer;
    m_grid_position  = Cursor();
    m_parent_lines   = &tlines;
    m_user_selection = selection;
    DefaultWordBreaker dwb;
    tlines.stream_words(dwb, *this);
    if (m_grid_position.line != height_c) {
        fill_remainder_with_blanks(writer, m_grid_position);
    }
    return;
#   endif
#   if 1
    CursorPair cursors;
    cursors.textlines = textlines_cursor;
    cursors.grid = Cursor(0, 0);
    const auto tlines_end_c = tlines.end_cursor();

    std::u32string buff;
    while (cursors.textlines != tlines_end_c && cursors.grid.line != height_c) {
        auto uchr = tlines.read_character(cursors.textlines);
        switch (uchr) {
        case U' ':
            cursors.in_text_lines = true;
            cursors.grid = render_word_to(writer, cursors, buff, selection, tlines);
            cursors.grid = print_space(writer, cursors, selection);
            record_cursor_mappings(m_cursor_maps, cursors.grid, cursors.textlines);
            buff.clear();
            break;
        case U'\t':
            cursors.in_text_lines = true;
            cursors.grid = render_word_to(writer, cursors, buff, selection, tlines);
            for (int i = 0; i != DEFAULT_TAB_WIDTH; ++i) {
                cursors.grid = print_space(writer, cursors, selection);
                record_cursor_mappings(m_cursor_maps, cursors.grid, cursors.textlines);
            }
            buff.clear();
            break;
        case TextLines::NEW_LINE:
            cursors.in_text_lines = true;
            cursors.grid = render_word_to(writer, cursors, buff, selection, tlines);
            cursors.in_text_lines = false;
            cursors.grid = fill_remainder_line_with_blanks(writer, cursors);
            buff.clear();
            break;
        default:
            buff += uchr;
            break;
        };
        cursors.textlines = tlines.next_cursor(cursors.textlines);
    }
    if (cursors.grid.line != height_c) {
        cursors.grid = render_word_to(writer, cursors, buff, selection, tlines);
        fill_remainder_with_blanks(writer, cursors.grid);
    }
#   endif
}
#if 0
/* private */ void TextRenderer::stream_word
    (const std::u32string & word, Cursor textline_cursor)
{
    const auto width = m_target_writer->width();
    CursorPair cpair;
    cpair.grid = m_grid_position;
    cpair.textlines = textline_cursor;
    cpair.in_text_lines = true;
    if (int(word.size()) >= width) {
        m_grid_position = render_word_hard_wrap(*m_target_writer, cpair, word, m_user_selection, *m_parent_lines);
    } else if (int(word.size()) >= width - cpair.grid.column) {
        m_grid_position = render_word_soft_wrap(*m_target_writer, cpair, word, m_user_selection, *m_parent_lines);
    } else {
        m_grid_position = render_word_no_wrap(*m_target_writer, cpair, word, m_user_selection, *m_parent_lines);
    }
}

/* private */ void TextRenderer::stream_whitespace
    (UChar wspace, Cursor textline_cursor)
{
    CursorPair cpair;
    cpair.grid = m_grid_position;
    cpair.textlines = textline_cursor;
    if (wspace == U' ') {
        m_grid_position = print_space(*m_target_writer, cpair, m_user_selection);
    } else {
        assert(wspace == TextLines::NEW_LINE);
        m_grid_position = fill_remainder_line_with_blanks(*m_target_writer, cpair);
    }
}
#endif
/* private */ Cursor TextRenderer::render_word_to
    (GridWriter & writer, const CursorPair & cursors,
     const std::u32string & buff, const UserTextSelection & selection,
     const TextLines & tlines)
{
    if (buff.empty()) return cursors.grid;
    const auto width = writer.width();
    assert(cursors.grid.line <= writer.height() &&
           cursors.grid.column < writer.width());
    if (int(buff.size()) >= width) {
        return render_word_hard_wrap(writer, cursors, buff, selection, tlines);
    } else if (cursors.grid.column + int(buff.size()) >= width) {
        return render_word_soft_wrap(writer, cursors, buff, selection, tlines);
    } else {
        return render_word_no_wrap(writer, cursors, buff, selection, tlines);
    }
}

/* private */ Cursor TextRenderer::render_word_hard_wrap
    (GridWriter & writer, const CursorPair & cursors,
     const std::u32string & buff, const UserTextSelection & selection,
     const TextLines & tlines)
{
    // hard wrap
    // not enough space for an entire grid line
    using HighlightBool = UserTextSelection::StringSelectionIters::HighlightBool;
    using CIter         = std::u32string::const_iterator;

    auto grid_pos = cursors.grid;
    const auto word_colors_c = m_info.pair_for_word(buff);
    // is not the start of "buff"
    auto tline_cursor = cursors.textlines;
    tline_cursor.column -= int(buff.size());
    // must be same text line
    assert(tlines.is_valid_cursor(tline_cursor));
    std::u32string temp;
    auto selobj = selection.ranges_for_string(tline_cursor, buff, tlines);
    selobj.for_each_iterator_pair([&](CIter beg, CIter end, HighlightBool h) {
        if (grid_pos.line == writer.height()) return;
        auto word_colors = word_colors_c;
        if (h == HighlightBool::HIGHLIGHT) {
            word_colors = apply_to<invert>(word_colors_c);
        }
        // write as many as possible, then move on to next text grid line
        int available = writer.width() - grid_pos.column;
        for (auto itr = beg; itr != end;) {
            if (available < end - itr) {
                temp = std::u32string(itr, itr + available);
                writer.write(word_colors, grid_pos, temp);
                record_cursor_mappings
                    (m_cursor_maps, grid_pos, tline_cursor, temp);
                writer.write(word_colors,
                             Cursor(grid_pos.line, writer.width() - 1),
                             TextLines::NEW_LINE);
                grid_pos.column = 0;
                ++grid_pos.line;
                tline_cursor.column += int(temp.size());
                available = writer.width();
                if (grid_pos.line == writer.height())
                    return; // we must finish, no room left...
                itr += available;
            } else {
                temp = std::u32string(itr, end);
                record_cursor_mappings
                    (m_cursor_maps, grid_pos, tline_cursor, temp);
                writer.write(word_colors, grid_pos, temp);
                grid_pos    .column += int(temp.size());
                tline_cursor.column += int(temp.size());
                break;
            }
        }
    });
    return grid_pos;
}

/* private */ Cursor TextRenderer::render_word_soft_wrap
    (GridWriter & writer, const CursorPair & cursors,
     const std::u32string & buff, const UserTextSelection & selection,
     const TextLines & tlines)
{
    // soft wrap
    // fill line with blanks, procede and write to next line
    // unless out of space
    assert(cursors.grid.column + int(buff.size()) >= writer.width());
    Cursor grid_pos = fill_remainder_line_with_blanks(writer, cursors);
    if (grid_pos.line == writer.height()) return grid_pos;
    CursorPair new_cursor_pair = cursors;
    new_cursor_pair.grid = grid_pos;
    return render_word_no_wrap(writer, new_cursor_pair, buff, selection, tlines);
}

/* private */ Cursor TextRenderer::render_word_no_wrap
    (GridWriter & writer, const CursorPair & cursors,
     const std::u32string & buff, const UserTextSelection & selection,
     const TextLines & tlines)
{
    using HighlightBool = UserTextSelection::StringSelectionIters::HighlightBool;
    using CIter         = std::u32string::const_iterator;

    const auto word_colors_c = m_info.pair_for_word(buff);

    auto tline_pos = cursors.textlines;
    tline_pos.column -= int(buff.size());
    assert(tlines.is_valid_cursor(tline_pos));
    auto sel_obj = selection.ranges_for_string(tline_pos, buff, tlines);
    auto grid_pos = cursors.grid;
    std::u32string temp;
    // guarantee: whole word will fit on line from current grid position
    // I capture everything because I'm naughty <:3
    // (Rationale, too much complexity/maintanence required to state the entire
    //  list explicitly)
    sel_obj.for_each_iterator_pair([&](CIter beg, CIter end, HighlightBool h) {
        auto word_colors = word_colors_c;
        if (h == HighlightBool::HIGHLIGHT) {
            word_colors = apply_to<invert>(word_colors);
        }
        temp = std::u32string(beg, end);
        writer.write(word_colors, grid_pos, temp);
        record_cursor_mappings(m_cursor_maps, grid_pos, tline_pos, temp);
        tline_pos.column += (end - beg);
        grid_pos .column += (end - beg);
    });
    return grid_pos;
}

/* private */ Cursor TextRenderer::print_space
    (GridWriter & writer, const CursorPair & cursors,
     const UserTextSelection & selection) const
{
    ColorPair colors(m_info.default_fore, m_info.default_back);
    if (selection.is_in_range(cursors.textlines)) {
        colors = apply_to<invert>(colors);
    }
    writer.write(colors, cursors.grid, U' ');
    return writer.next_cursor(cursors.grid);
}

/* private */ Cursor TextRenderer::fill_remainder_line_with_blanks
    (GridWriter & writer, const CursorPair & cursors) const
{
    auto old_line = cursors.grid.line;
    auto new_grid_pos = cursors.grid;
    const auto width_c = writer.width();
    assert(old_line != writer.height());
    ColorPair colors(m_info.default_fore, m_info.default_back);
    while (width_c != new_grid_pos.column) {
        writer.write(colors, new_grid_pos, U' ');
        ++new_grid_pos.column;
    }
    writer.write(colors, Cursor(new_grid_pos.line, new_grid_pos.column - 1),
                 TextLines::NEW_LINE);
    new_grid_pos.column = 0;
    ++new_grid_pos.line;
    return new_grid_pos;
}

/* private */ void TextRenderer::fill_remainder_with_blanks
    (GridWriter & writer, Cursor grid_pos)
{
    auto prev_cursor = [&writer](Cursor cursor) {
        if (--cursor.column < 0) {
            --cursor.line;
            cursor.column = writer.width() - 1;
        }
        return cursor;
    };
    Cursor grid_end = writer.end_cursor();
    ColorPair colors(m_info.default_fore, m_info.default_back);
    while (grid_pos != grid_end) {
        writer.write(colors, grid_pos, U' ');
        grid_pos = writer.next_cursor(grid_pos);
        if (grid_pos.column == 0) {
            writer.write(colors, prev_cursor(grid_pos), TextLines::NEW_LINE);
        }
    }
}

void TextRenderer::add_keyword(const std::u32string & keyword) {
    m_info.keywords.insert(keyword);
}

void TextRenderer::assign_cursor_maps(TextLineGridDoubleMap * maps) {
    m_cursor_maps = maps;
}

/* static */ void TextRenderer::run_tests() {
    run_text_renderer_tests();
}

/* static */ bool TextRenderer::is_whitespace(UChar c) {
    return c == U' ' || c == U'\t' || c == U'\r' || c == U'\n';
}

/* static */ sf::Color TextRenderer::invert(sf::Color color) {
    return sf::Color(255 - color.r, 255 - color.g, 255 - color.b, color.a);
}

// ----------------------------------------------------------------------------

/* private */ void UserTextSelection::StringSelectionIters::
    check_invarients() const
{
    assert(iterators_are_good());
}

// ----------------------------------------------------------------------------

namespace {

void TextGridWriter::write
    (ColorPair colors, Cursor cur, const std::u32string & ustr)
{
    // ensure behavior guarentee
    assert(parent_grid);
    assert(cur.column + int(ustr.size()) < width());
    verify_cursor_validity("HighlighterWriterDefs::TextGridWriter::write", cur);
    verify_parent_present("HighlighterWriterDefs::TextGridWriter::write");
    Cursor end_cursor(cur.line, cur.column + int(ustr.size()));
    auto ustr_itr = ustr.begin();
    for (; cur != end_cursor; ++cur.column) {
        assert(ustr_itr != ustr.end());
        parent_grid->set_cell(cur, colors.fore, colors.back, *ustr_itr);
        ++ustr_itr;
    }
}

void TextGridWriter::write
    (ColorPair colors, Cursor cur, UChar uc)
{
    verify_cursor_validity("HighlighterWriterDefs::TextGridWriter::write", cur);
    verify_parent_present("HighlighterWriterDefs::TextGridWriter::write");
    if (uc == TextLines::NEW_LINE) return;
    parent_grid->set_cell(cur, colors.fore, colors.back, uc);
}

int TextGridWriter::width() const {
    return parent_grid->width_in_cells();
}

int TextGridWriter::height() const {
    return parent_grid->height_in_cells();
}

void TextGridWriter::verify_parent_present
    (const char * funcname) const
{
    if (parent_grid) return;
    throw std::runtime_error(std::string(funcname) + ": parent grid is not "
                             "set, which is required for this function.");
}

void record_cursor_mappings
    (TextLineGridDoubleMap * maps, Cursor grid_pos, Cursor text_pos,
     const std::u32string & word)
{
    if (!maps) return;
    for (auto c : word) {
        (void)c;
        record_cursor_mappings(maps, grid_pos, text_pos);
        ++grid_pos.column;
        ++text_pos.column;
    }
}

void record_cursor_mappings
    (TextLineGridDoubleMap * maps, Cursor grid_pos, Cursor text_pos)
{
    if (!maps) return;
    maps->grid_to_textlines[grid_pos] = text_pos;
    maps->textlines_to_grid[text_pos] = grid_pos;
}

} // end of <anonymous> namespace
